/*
 * BrainRex API
 * The Brainrex API is a collection of analytics tools and data integrations made for blockchain developers. In particular we offer Natural Language Processing and Anomaly detection algorithms that have been fine tune to understand text data and time series in the domain speficic setting of cryptocurrency and blockchain technology. This technology is intended to be use as building blocks to bigger applications, we offer examples on how to use them for Trading Backtesting and Smart Contract anomaly monitoring.
 *
 * OpenAPI spec version: 1.0.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package brainrex;

import invalidPackageName.ApiCallback;
import invalidPackageName.ApiClient;
import invalidPackageName.ApiException;
import invalidPackageName.ApiResponse;
import invalidPackageName.Configuration;
import invalidPackageName.Pair;
import invalidPackageName.ProgressRequestBody;
import invalidPackageName.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.CandleRequest;
import io.swagger.client.model.CandleResponse;
import io.swagger.client.model.Exchange;
import io.swagger.client.model.ExchangeAssetsResponse;
import io.swagger.client.model.OrderbookRequest;
import io.swagger.client.model.OrderbookResponse;
import io.swagger.client.model.SupportedExchanges;
import io.swagger.client.model.TickerResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class IntegrationsApi {
    private ApiClient apiClient;

    public IntegrationsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public IntegrationsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for cryptoGetCandleData
     * @param candleRequest The Get candles end point return market data in Open High Close Volume format. In order to use this endpoint you need to enter your API keys to your data provider in the console (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call cryptoGetCandleDataCall(CandleRequest candleRequest, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = candleRequest;

        // create path and map variables
        String localVarPath = "/crypto/get_candles";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call cryptoGetCandleDataValidateBeforeCall(CandleRequest candleRequest, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'candleRequest' is set
        if (candleRequest == null) {
            throw new ApiException("Missing the required parameter 'candleRequest' when calling cryptoGetCandleData(Async)");
        }
        

        com.squareup.okhttp.Call call = cryptoGetCandleDataCall(candleRequest, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Downloads candle format market data
     * Returns a list of candle data from specified market and data range
     * @param candleRequest The Get candles end point return market data in Open High Close Volume format. In order to use this endpoint you need to enter your API keys to your data provider in the console (required)
     * @return CandleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public CandleResponse cryptoGetCandleData(CandleRequest candleRequest) throws ApiException {
        ApiResponse<CandleResponse> resp = cryptoGetCandleDataWithHttpInfo(candleRequest);
        return resp.getData();
    }

    /**
     * Downloads candle format market data
     * Returns a list of candle data from specified market and data range
     * @param candleRequest The Get candles end point return market data in Open High Close Volume format. In order to use this endpoint you need to enter your API keys to your data provider in the console (required)
     * @return ApiResponse&lt;CandleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<CandleResponse> cryptoGetCandleDataWithHttpInfo(CandleRequest candleRequest) throws ApiException {
        com.squareup.okhttp.Call call = cryptoGetCandleDataValidateBeforeCall(candleRequest, null, null);
        Type localVarReturnType = new TypeToken<CandleResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Downloads candle format market data (asynchronously)
     * Returns a list of candle data from specified market and data range
     * @param candleRequest The Get candles end point return market data in Open High Close Volume format. In order to use this endpoint you need to enter your API keys to your data provider in the console (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call cryptoGetCandleDataAsync(CandleRequest candleRequest, final ApiCallback<CandleResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = cryptoGetCandleDataValidateBeforeCall(candleRequest, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<CandleResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for cryptoGetExchangeAssets
     * @param exchange Name of the cryptocurrency exchange (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call cryptoGetExchangeAssetsCall(Exchange exchange, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = exchange;

        // create path and map variables
        String localVarPath = "/crypto/get_exchange_assets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call cryptoGetExchangeAssetsValidateBeforeCall(Exchange exchange, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'exchange' is set
        if (exchange == null) {
            throw new ApiException("Missing the required parameter 'exchange' when calling cryptoGetExchangeAssets(Async)");
        }
        

        com.squareup.okhttp.Call call = cryptoGetExchangeAssetsCall(exchange, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Gets all coin pairs traded in specified exchange
     * This endpoint returns all the Available currency pairs
     * @param exchange Name of the cryptocurrency exchange (required)
     * @return ExchangeAssetsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ExchangeAssetsResponse cryptoGetExchangeAssets(Exchange exchange) throws ApiException {
        ApiResponse<ExchangeAssetsResponse> resp = cryptoGetExchangeAssetsWithHttpInfo(exchange);
        return resp.getData();
    }

    /**
     * Gets all coin pairs traded in specified exchange
     * This endpoint returns all the Available currency pairs
     * @param exchange Name of the cryptocurrency exchange (required)
     * @return ApiResponse&lt;ExchangeAssetsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ExchangeAssetsResponse> cryptoGetExchangeAssetsWithHttpInfo(Exchange exchange) throws ApiException {
        com.squareup.okhttp.Call call = cryptoGetExchangeAssetsValidateBeforeCall(exchange, null, null);
        Type localVarReturnType = new TypeToken<ExchangeAssetsResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets all coin pairs traded in specified exchange (asynchronously)
     * This endpoint returns all the Available currency pairs
     * @param exchange Name of the cryptocurrency exchange (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call cryptoGetExchangeAssetsAsync(Exchange exchange, final ApiCallback<ExchangeAssetsResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = cryptoGetExchangeAssetsValidateBeforeCall(exchange, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ExchangeAssetsResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for cryptoGetOrderbooks
     * @param orderbookRequest Exchange, trading pair and date rage for data (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call cryptoGetOrderbooksCall(OrderbookRequest orderbookRequest, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = orderbookRequest;

        // create path and map variables
        String localVarPath = "/crypto/get_orderbooks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call cryptoGetOrderbooksValidateBeforeCall(OrderbookRequest orderbookRequest, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'orderbookRequest' is set
        if (orderbookRequest == null) {
            throw new ApiException("Missing the required parameter 'orderbookRequest' when calling cryptoGetOrderbooks(Async)");
        }
        

        com.squareup.okhttp.Call call = cryptoGetOrderbooksCall(orderbookRequest, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Returns the current state of the orderbook.
     * This endpoint returns the current state of the ordebook with a limit set by you. The maximun orderbook depth is 25.
     * @param orderbookRequest Exchange, trading pair and date rage for data (required)
     * @return OrderbookResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public OrderbookResponse cryptoGetOrderbooks(OrderbookRequest orderbookRequest) throws ApiException {
        ApiResponse<OrderbookResponse> resp = cryptoGetOrderbooksWithHttpInfo(orderbookRequest);
        return resp.getData();
    }

    /**
     * Returns the current state of the orderbook.
     * This endpoint returns the current state of the ordebook with a limit set by you. The maximun orderbook depth is 25.
     * @param orderbookRequest Exchange, trading pair and date rage for data (required)
     * @return ApiResponse&lt;OrderbookResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<OrderbookResponse> cryptoGetOrderbooksWithHttpInfo(OrderbookRequest orderbookRequest) throws ApiException {
        com.squareup.okhttp.Call call = cryptoGetOrderbooksValidateBeforeCall(orderbookRequest, null, null);
        Type localVarReturnType = new TypeToken<OrderbookResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Returns the current state of the orderbook. (asynchronously)
     * This endpoint returns the current state of the ordebook with a limit set by you. The maximun orderbook depth is 25.
     * @param orderbookRequest Exchange, trading pair and date rage for data (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call cryptoGetOrderbooksAsync(OrderbookRequest orderbookRequest, final ApiCallback<OrderbookResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = cryptoGetOrderbooksValidateBeforeCall(orderbookRequest, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<OrderbookResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for cryptoGetSupportedExchanges
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call cryptoGetSupportedExchangesCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/crypto/get_supported_exchanges";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call cryptoGetSupportedExchangesValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = cryptoGetSupportedExchangesCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * Gets all cryptocurrency exchanges supported by the Brainrex API
     * Returns a list of candle data from specified market and data range
     * @return SupportedExchanges
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public SupportedExchanges cryptoGetSupportedExchanges() throws ApiException {
        ApiResponse<SupportedExchanges> resp = cryptoGetSupportedExchangesWithHttpInfo();
        return resp.getData();
    }

    /**
     * Gets all cryptocurrency exchanges supported by the Brainrex API
     * Returns a list of candle data from specified market and data range
     * @return ApiResponse&lt;SupportedExchanges&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<SupportedExchanges> cryptoGetSupportedExchangesWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = cryptoGetSupportedExchangesValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<SupportedExchanges>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Gets all cryptocurrency exchanges supported by the Brainrex API (asynchronously)
     * Returns a list of candle data from specified market and data range
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call cryptoGetSupportedExchangesAsync(final ApiCallback<SupportedExchanges> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = cryptoGetSupportedExchangesValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<SupportedExchanges>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for cryptoGetTicker
     * @param exchange Get ticker data from specified crypto exchange (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call cryptoGetTickerCall(Exchange exchange, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = exchange;

        // create path and map variables
        String localVarPath = "/crypto/get_ticker";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call cryptoGetTickerValidateBeforeCall(Exchange exchange, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'exchange' is set
        if (exchange == null) {
            throw new ApiException("Missing the required parameter 'exchange' when calling cryptoGetTicker(Async)");
        }
        

        com.squareup.okhttp.Call call = cryptoGetTickerCall(exchange, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Downloads candle format market data
     * Returns a list of candle data from specified market and data range
     * @param exchange Get ticker data from specified crypto exchange (required)
     * @return TickerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TickerResponse cryptoGetTicker(Exchange exchange) throws ApiException {
        ApiResponse<TickerResponse> resp = cryptoGetTickerWithHttpInfo(exchange);
        return resp.getData();
    }

    /**
     * Downloads candle format market data
     * Returns a list of candle data from specified market and data range
     * @param exchange Get ticker data from specified crypto exchange (required)
     * @return ApiResponse&lt;TickerResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TickerResponse> cryptoGetTickerWithHttpInfo(Exchange exchange) throws ApiException {
        com.squareup.okhttp.Call call = cryptoGetTickerValidateBeforeCall(exchange, null, null);
        Type localVarReturnType = new TypeToken<TickerResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Downloads candle format market data (asynchronously)
     * Returns a list of candle data from specified market and data range
     * @param exchange Get ticker data from specified crypto exchange (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call cryptoGetTickerAsync(Exchange exchange, final ApiCallback<TickerResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = cryptoGetTickerValidateBeforeCall(exchange, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<TickerResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
